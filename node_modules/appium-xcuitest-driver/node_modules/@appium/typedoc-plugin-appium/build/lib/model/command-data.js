"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecMethodData = exports.CommandData = exports.BaseCommandData = void 0;
const lodash_1 = __importDefault(require("lodash"));
const converter_1 = require("../converter");
const guards_1 = require("../guards");
const utils_1 = require("../utils");
/**
 * Abstract representation of metadata for some sort of Appium command
 */
class BaseCommandData {
    constructor(log, command, methodRefl, opts = {}) {
        this.command = command;
        this.methodRefl = methodRefl;
        this.log = log;
        this.optionalParams = opts.optionalParams;
        this.requiredParams = opts.requiredParams;
        this.commentSource = opts.commentSource;
        this.parentRefl = opts.parentRefl;
        this.knownBuiltinMethods = opts.knownBuiltinMethods;
        this.isPluginCommand = Boolean(opts.isPluginCommand);
        const extractedExamples = (0, converter_1.extractExamples)(opts.comment);
        if (extractedExamples?.comment) {
            this.comment = extractedExamples.comment;
        }
        if (extractedExamples?.examples) {
            this.examples = extractedExamples.examples;
        }
        this.parameters = BaseCommandData.rewriteParameters(this);
        this.signature = BaseCommandData.rewriteSignature(this);
    }
    /**
     * Returns `true` if the method or execute map defined parameters for this command
     */
    get hasCommandParams() {
        return Boolean(this.optionalParams?.length || this.requiredParams?.length);
    }
}
exports.BaseCommandData = BaseCommandData;
/**
 * Returns a list of `ParameterReflection` objects in the command's method declaration;
 * rewrites them to prefer the method map parameter list (and the param names)
 **/
BaseCommandData.rewriteParameters = lodash_1.default.memoize((cmd) => {
    if (!cmd.hasCommandParams) {
        return;
    }
    const signature = (0, utils_1.findCallSignature)(cmd.methodRefl);
    if (!signature || !signature.parameters?.length) {
        // no parameters
        return;
    }
    const newParamRefls = [
        ...(0, converter_1.createNewParamRefls)(signature, {
            builtinMethods: cmd.knownBuiltinMethods,
            commandParams: cmd.requiredParams,
            isPluginCommand: cmd.isPluginCommand,
        }),
        ...(0, converter_1.createNewParamRefls)(signature, {
            builtinMethods: cmd.knownBuiltinMethods,
            commandParams: cmd.optionalParams,
            isPluginCommand: cmd.isPluginCommand,
            isOptional: true,
        }),
    ];
    return newParamRefls;
});
/**
 * Rewrites a method's return value for documentation.
 *
 * Given a command having a method declaration, creates a clone of its call signature wherein the
 * return type is unwrapped from `Promise`.  In other words, if a method returns `Promise<T>`,
 * this changes the return type in the signature to `T`.
 *
 * Note that the return type of a command's method declaration should always be a `ReferenceType` having
 * name `Promise`.
 */
BaseCommandData.rewriteSignature = lodash_1.default.memoize((cmd) => {
    const callSig = (0, utils_1.findCallSignature)(cmd.methodRefl);
    if (!callSig) {
        return;
    }
    if ((0, guards_1.isReferenceType)(callSig.type) && callSig.type.name === 'Promise') {
        // this does the actual unwrapping.  `Promise` only has a single type argument `T`,
        // so we can safely use the first one.
        const newType = lodash_1.default.first(callSig.type.typeArguments);
        const newCallSig = (0, converter_1.cloneSignatureReflection)(callSig, cmd.methodRefl, newType);
        if (!newCallSig.type) {
            cmd.log.warn('(%s) No type arg T found for return type Promise<T> in %s; this is a bug', cmd.parentRefl.name, cmd.methodRefl.name);
            return;
        }
        newCallSig.comment = (0, converter_1.deriveComment)({
            refl: newCallSig,
            knownMethods: cmd.knownBuiltinMethods,
        })?.comment;
        return newCallSig;
    }
});
/**
 * Represents a generic WD or Appium-specific endpoint
 */
class CommandData extends BaseCommandData {
    constructor(log, command, methodRefl, httpMethod, route, opts = {}) {
        super(log, command, methodRefl, opts);
        this.httpMethod = httpMethod;
        this.route = route;
    }
    /**
     * Creates a **shallow** clone of this instance.
     *
     * Keeps props {@linkcode BaseCommandData.command command},
     * {@linkcode CommandData.httpMethod httpMethod} and
     * {@linkcode CommandData.route route}, then applies any other options.
     * @param opts Options to apply. _Note:_ you probably want to provide a new `parentRefl`.
     * @returns Cloned instance
     */
    clone(methodRefl, opts = {}) {
        return new CommandData(this.log, this.command, methodRefl, this.httpMethod, this.route, {
            ...this,
            ...opts,
        });
    }
}
exports.CommandData = CommandData;
/**
 * Represents an "execute command" ("execute method")
 *
 * Each will have a unique `script` property which is provided as the script to run via the
 * `execute` WD endpoint.
 *
 * All of these share the same `execute` route, so it is omitted from this interface.
 */
class ExecMethodData extends BaseCommandData {
    constructor(log, command, methodRefl, script, opts = {}) {
        super(log, command, methodRefl, opts);
        this.script = script;
    }
    /**
     * Creates a **shallow** clone of this instance.
     *
     * Keeps props {@linkcode BaseCommandData.command command}, {@linkcode ExecMethod.script script},
     * then applies any other options.
     * @param opts Options to apply
     * @returns Cloned instance
     */
    clone(opts) {
        return new ExecMethodData(this.log, this.command, this.methodRefl, this.script, {
            ...this,
            ...opts,
        });
    }
}
exports.ExecMethodData = ExecMethodData;
//# sourceMappingURL=command-data.js.map